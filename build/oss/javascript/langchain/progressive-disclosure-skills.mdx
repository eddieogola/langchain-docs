---
title: Build an agent with progressive disclosure and skills
sidebarTitle: Progressive disclosure & skills
---

import ChatModelTabsPy from '/snippets/chat-model-tabs.mdx';
import ChatModelTabsJs from '/snippets/chat-model-tabs-js.mdx';

This tutorial shows how to use **progressive disclosure** - a context management technique where the agent loads information on-demand rather than upfront - to implement **skills** (specialized prompt-based instructions). The agent loads skills via tool calls, rather than dynamically changing the system prompt, discovering and loading only the skills it needs for each task.

**What you'll build:** An employee support agent with two skills (expense reporting and travel booking). The agent sees lightweight skill descriptions in its system prompt, then loads full skill content through tool calls only when relevant to the user's query.

**Why progressive disclosure:**
- **Reduces context usage** - load only the 2-3 skills needed for a task, not all available skills
- **Enables team autonomy** - different teams can develop specialized skills independently (similar to other multi-agent architectures)
- **Scales efficiently** - add dozens or hundreds of skills without overwhelming context
- **Simplifies conversation history** - single agent with one conversation thread

**What are skills:** Skills, as popularized by Claude Code, are primarily prompt-based: self-contained units of specialized instructions for specific business tasks. In Claude Code, skills are exposed as directories with files on the file system, discovered through file operations. Skills guide behavior through prompts and can provide information about tool usage or include sample code for a coding agent to execute.

<Tip>
Skills with progressive disclosure can be viewed as a form of RAG (Retrieval-Augmented Generation), where each skill is a retrieval unitâ€”though not necessarily backed by embeddings or keyword search, but by tools for browsing content (like file operations or, in this tutorial, direct lookup).
</Tip>

**Trade-offs:** Progressive disclosure requires additional tool calls to load skills, which can introduce noticeable latency depending on your architecture. With basic implementations, you cannot enforce workflow constraints (e.g., skill A must be tried before skill B) - you rely on prompting alone.

<Tip>
**Implementing your own skills system**

When building your own skills implementation (as we do in this tutorial), the core concept is progressive disclosure - loading information on-demand. Beyond that, you have full flexibility in implementation:

- **Storage**: databases, S3, in-memory data structures, or any backend
- **Discovery**: direct lookup (this tutorial), RAG for large skill collections, file system scanning, or API calls
- **Loading logic**: customize latency characteristics and add logic to search through skill content or rank relevance
- **Side effects**: define what happens when a skill loads, such as exposing tools associated with that skill (covered in section 8)

This flexibility lets you optimize for your specific requirements around performance, storage, and workflow control.
</Tip>

## Architecture overview

Here's how progressive disclosure with skills works:

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#4CAF50','primaryTextColor':'#fff','primaryBorderColor':'#2E7D32','lineColor':'#666','secondaryColor':'#FF9800','tertiaryColor':'#2196F3','tertiaryBorderColor':'#1565C0','tertiaryTextColor':'#fff'}}}%%
flowchart TD
    Start([ðŸ’¬ User Query]) --> SystemPrompt[ðŸ“‹ Skill descriptions<br/>in system prompt]

    SystemPrompt --> Decide{ðŸ¤” Which skill<br/>is relevant?}

    Decide --> LoadSkill[ðŸ”§ Call load_skill<br/>tool]

    LoadSkill --> Enriched[âœ¨ Skill content returned<br/>in tool result]

    Enriched --> Solve[ðŸ’¡ Apply skill<br/>to answer]

    Solve --> Response([âœ… Response])

    %% Styling for light and dark modes
    classDef startEnd fill:#4CAF50,stroke:#2E7D32,stroke-width:2px,color:#fff
    classDef process fill:#FF9800,stroke:#E65100,stroke-width:2px,color:#fff
    classDef decision fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#fff
    classDef enrichment fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#fff

    class Start,Response startEnd
    class SystemPrompt,LoadSkill,Solve process
    class Decide decision
    class Enriched enrichment
```

## Setup

### Installation

This tutorial requires the `langchain` package:



<CodeGroup>
```bash npm
npm install langchain
```
```bash yarn
yarn add langchain
```
```bash pnpm
pnpm add langchain
```
</CodeGroup>


For more details, see our [Installation guide](/oss/javascript/langchain/install).

### LangSmith

Set up [LangSmith](https://smith.langchain.com) to inspect what is happening inside your agent. Then set the following environment variables:



<CodeGroup>
```bash bash
export LANGSMITH_TRACING="true"
export LANGSMITH_API_KEY="..."
```
```typescript typescript
process.env.LANGSMITH_TRACING = "true";
process.env.LANGSMITH_API_KEY = "...";
```
</CodeGroup>


### Components

We will need to select a chat model from LangChain's suite of integrations:



<ChatModelTabsJs />


## 1. Define skills

First, define the structure for skills. Each skill has a name, a brief description (shown in the system prompt), and full content (loaded on-demand):

```python
from typing import TypedDict

class Skill(TypedDict):
    """A skill that can be progressively disclosed to the agent."""
    name: str  # Unique identifier for the skill
    description: str  # Brief description shown in system prompt (1-2 sentences)
    content: str  # Full skill content with detailed instructions
```

Now define example skills for an employee support agent. The skills are designed to be **lightweight in description** (shown to the agent upfront) but **detailed in content** (loaded only when needed):

<Accordion title="View complete skill definitions">

```python
SKILLS: list[Skill] = [
    {
        "name": "expense_reporting",
        "description": "Handles expense report submission, approval workflows, and reimbursement status inquiries.",
        "content": """# Expense Reporting Skill

You help employees with expense reports. You can:

1. **Submit expense reports**: Guide employees through submitting new expense reports
   - Required fields: date, amount, category, description, receipt
   - Categories: travel, meals, supplies, software, other
   - Receipts must be attached for expenses over $25

2. **Check status**: Look up the status of submitted expense reports
   - Pending: awaiting manager approval
   - Approved: approved and queued for payment
   - Paid: reimbursement processed
   - Rejected: needs revision (check rejection reason)

3. **Approval workflows**: Expenses under $100 auto-approve, over $100 need manager approval

Always be specific about next steps and timelines (payments process weekly on Fridays).""",
    },
    {
        "name": "travel_booking",
        "description": "Handles flight and hotel bookings, travel policy questions, and itinerary management.",
        "content": """# Travel Booking Skill

You help employees book business travel. You can:

1. **Book flights**: Help find and book flights within travel policy
   - Must use preferred airlines: United, Delta, American
   - Economy class for flights under 5 hours
   - Business class allowed for international flights over 5 hours
   - Book at least 14 days in advance when possible

2. **Book hotels**: Help find and book hotels within travel policy
   - Per night limit: $200 in most cities, $300 in high-cost cities (NYC, SF, LA, DC)
   - Must use corporate booking portal for best rates
   - Preferred hotel chains: Marriott, Hilton, Hyatt

3. **Travel policy**: Answer questions about travel policy, expense limits, and approval requirements

Always verify trip dates, destination, and get manager approval before booking.""",
    },
]
```

</Accordion>

## 2. Build skill middleware

Create custom middleware that injects skill descriptions into the system prompt. This middleware makes skills discoverable without loading their full content upfront.

<Note>
This guide demonstrates creating custom middleware. For a comprehensive guide on middleware concepts and patterns, see the [custom middleware documentation](/oss/javascript/python/langchain/middleware/custom).
</Note>

```python
from langchain.agents.middleware import wrap_model_call, ModelRequest, ModelResponse, AgentMiddleware
from langchain_core.messages import SystemMessage
from langchain.tools import tool
from typing import Callable

class SkillMiddleware(AgentMiddleware):
    """Middleware that injects skill descriptions into the system prompt."""

    def __init__(self):
        """Initialize and generate the skills prompt from SKILLS."""
        # Build skills prompt from the SKILLS list
        skills_list = []
        for skill in SKILLS:
            skills_list.append(f"- **{skill['name']}**: {skill['description']}")
        self.skills_prompt = "\n".join(skills_list)

        # Define the load_skill tool
        @tool
        def load_skill(skill_name: str) -> str:
            """Load the full content of a skill into the agent's context.

            Use this when you need detailed information about how to handle a specific
            type of request. This will provide you with comprehensive instructions,
            policies, and guidelines for the skill area.

            Args:
                skill_name: The name of the skill to load (e.g., "expense_reporting", "travel_booking")
            """
            # Find and return the requested skill
            for skill in SKILLS:
                if skill["name"] == skill_name:
                    return f"Loaded skill: {skill_name}\n\n{skill['content']}"

            # Skill not found
            available = ", ".join(s["name"] for s in SKILLS)
            return f"Skill '{skill_name}' not found. Available skills: {available}"

        # Register the tool as an instance variable
        self.tools = [load_skill]

    @wrap_model_call
    async def awrap_model_call(
        self,
        request: ModelRequest,
        handler: Callable[[ModelRequest], ModelResponse],
    ) -> ModelResponse:
        """Async: Inject skill descriptions into system prompt."""
        # Build the skills addendum
        skills_addendum = f"\n\n## Available Skills\n\n{self.skills_prompt}\n\nUse the load_skill tool when you need detailed information about handling a specific type of request."

        # Append to system message content blocks
        new_content = list(request.system_message.content_blocks) + [
            {"type": "text", "text": skills_addendum}
        ]
        new_system_message = SystemMessage(content=new_content)

        return await handler(request.override(system_message=new_system_message))

    @wrap_model_call
    def wrap_model_call(
        self,
        request: ModelRequest,
        handler: Callable[[ModelRequest], ModelResponse],
    ) -> ModelResponse:
        """Sync: Inject skill descriptions into system prompt."""
        # Build the skills addendum
        skills_addendum = f"\n\n## Available Skills\n\n{self.skills_prompt}\n\nUse the load_skill tool when you need detailed information about handling a specific type of request."

        # Append to system message content blocks
        new_content = list(request.system_message.content_blocks) + [
            {"type": "text", "text": skills_addendum}
        ]
        new_system_message = SystemMessage(content=new_content)

        return handler(request.override(system_message=new_system_message))
```

The middleware appends skill descriptions to the system prompt, making the agent aware of available skills without loading their full content. The `load_skill` tool is defined within the `__init__` method and registered as an instance variable (`self.tools`), making it available to the agent.

## 3. Create the agent with skill support

Now create the agent with the skill middleware and a checkpointer for state persistence:

```python
from langchain.agents import create_agent
from langgraph.checkpoint.memory import InMemorySaver

# Create the agent with skill support
agent = create_agent(
    model,
    system_prompt="You are a helpful employee support assistant.",
    middleware=[SkillMiddleware()],  # Automatically generates skills prompt from SKILLS
    checkpointer=InMemorySaver(),
)
```

The agent now has access to skill descriptions in its system prompt and can call `load_skill` to retrieve full skill content when needed. The checkpointer maintains conversation history across turns.

## 4. Test progressive disclosure

Test the agent with a question that requires skill-specific knowledge:

```python
import uuid

# Configuration for this conversation thread
thread_id = str(uuid.uuid4())
config = {"configurable": {"thread_id": thread_id}}

# Ask about expense reporting
result = agent.invoke(
    {"messages": [{"role": "user", "content": "I need to submit an expense report for a $150 dinner. What information do I need to provide?"}]},
    config
)

# Print the conversation
for message in result["messages"]:
    if hasattr(message, 'pretty_print'):
        message.pretty_print()
    else:
        print(f"{message.type}: {message.content}")
```

Expected output:

```
================================ Human Message =================================

I need to submit an expense report for a $150 dinner. What information do I need to provide?
================================== Ai Message ==================================
Tool Calls:
  load_skill (call_pq6JpWMOvikULdhVauwFIFti)
 Call ID: call_pq6JpWMOvikULdhVauwFIFti
  Args:
    skill_name: expense_reporting
================================= Tool Message =================================
Name: load_skill

Loaded skill: expense_reporting

# Expense Reporting Skill

You help employees with expense reports. You can:

1. **Submit expense reports**: Guide employees through submitting new expense reports
   - Required fields: date, amount, category, description, receipt
   - Categories: travel, meals, supplies, software, other
   - Receipts must be attached for expenses over $25

2. **Check status**: Look up the status of submitted expense reports
   - Pending: awaiting manager approval
   - Approved: approved and queued for payment
   - Paid: reimbursement processed
   - Rejected: needs revision (check rejection reason)

3. **Approval workflows**: Expenses under $100 auto-approve, over $100 need manager approval

Always be specific about next steps and timelines (payments process weekly on Fridays).
================================== Ai Message ==================================

When submitting your expense report for the $150 dinner, the following information is required:

1. Date of the expense
2. Amount of the expense - in this case $150
3. Category of the expense - it looks like this would fall under 'meals'
4. A description of the expense
5. Receipt for the dinner (as it's over $25)

Make sure your receipt clearly shows all these details. Given that the expense is over $100, it will need manager approval. Once approved, it will be queued for payment. Payments are processed weekly on Fridays.
```

The agent saw the lightweight skill description in its system prompt, recognized the question was about expense reporting, called `load_skill("expense_reporting")` to get the full content, and then used that detailed knowledge to provide a comprehensive answer.

## 5. Advanced: Enforce tools per skill with middleware

[PLACEHOLDER: Show how to use custom middleware to enforce that certain tools are only available when specific skills are loaded. This goes beyond the basic prompt-based approach and adds rigid constraints. Example: when the expense_reporting skill is loaded, register expense-specific tools like submit_expense_report or check_expense_status. The middleware can track loaded_skills in state and conditionally register tools based on which skills are active.]

## Complete example

[PLACEHOLDER: Full runnable script combining all the pieces]

## Implementation variations

This tutorial implemented skills as in-memory Python dictionaries loaded through tool calls. However, there are several ways to implement progressive disclosure with skills:

**Storage backends:**
- **In-memory** (this tutorial): Skills defined as Python data structures, fast access, no I/O overhead
- **File system** (Claude Code approach): Skills as directories with files, discovered via file operations like `read_file`
- **Remote storage**: Skills in S3, databases, or APIs, fetched on-demand
- **Hybrid**: Skill descriptions in-memory, full content fetched from remote storage

**Discovery mechanisms:**
- **Direct loading**: If skills are small, load them directly without separate discovery steps
- **Two-phase**: List available skills first, then load specific ones (used in this tutorial)
- **File-based**: Discover skills by scanning directories (Claude Code approach)
- **Registry-based**: Query a skill registry service for available skills

**Size considerations:**
- **Small skills** (< 1KB): Can be loaded directly or even included in system prompt
- **Medium skills** (1-10KB): Benefit from progressive disclosure (this tutorial)
- **Large skills** (> 10KB): May need chunking, summarization, or selective loading

The choice depends on your requirements: in-memory is fastest but requires redeployment for skill updates, while file-based or remote storage enables dynamic skill management without code changes.

## Next steps

- Learn about [middleware](/oss/javascript/langchain/middleware) for more dynamic agent behaviors
- Explore the [handoffs pattern](/oss/javascript/langchain/customer-support-handoffs) for sequential workflows
- Read the [supervisor pattern](/oss/javascript/langchain/supervisor) for parallel task routing
- Use [LangSmith](https://smith.langchain.com) to debug and monitor skill loading

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/progressive-disclosure-skills.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.
</Tip>
